From 34b6d037eb582047b376728fdd3649470a30c933 Mon Sep 17 00:00:00 2001
From: Frederic Crozat <fcrozat@suse.com>
Date: Wed, 21 Mar 2012 18:03:40 +0100
Subject: [PATCH] main: allow system wide limits for services
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Backported-by: Łukasz Stelmach <l.stelmach@samsung.com>
Signed-off-by: Łukasz Stelmach <l.stelmach@samsung.com>
[ fix build break ]
Signed-off-by: Karol Lewandowski <k.lewandowsk@samsung.com>
---
 man/systemd.conf.xml |   72 ++++++++++++++++++++++++++++++++++++++++++++++++++
 src/main.c           |   22 +++++++++++++++
 src/manager.c        |   22 +++++++++++++++
 src/manager.h        |    3 +++
 src/service.c        |    4 +++
 5 files changed, 123 insertions(+)

diff --git a/man/systemd.conf.xml b/man/systemd.conf.xml
index ba144da..d37c574 100644
--- a/man/systemd.conf.xml
+++ b/man/systemd.conf.xml
@@ -149,6 +149,78 @@
                                 controllers in separate
                                 hierarchies.</para></listitem>
                         </varlistentry>
+
+                        <varlistentry>
+                                <term><varname>RuntimeWatchdogSec=</varname></term>
+                                <term><varname>ShutdownWatchdogSec=</varname></term>
+
+                                <listitem><para>Configure the hardware
+                                watchdog at runtime and at
+                                reboot. Takes a timeout value in
+                                seconds (or in other time units if
+                                suffixed with <literal>ms</literal>,
+                                <literal>min</literal>,
+                                <literal>h</literal>,
+                                <literal>d</literal>,
+                                <literal>w</literal>). If
+                                <varname>RuntimeWatchdogSec=</varname>
+                                is set to a non-zero value the
+                                watchdog hardware
+                                (<filename>/dev/watchdog</filename>)
+                                will be programmed to automatically
+                                reboot the system if it is not
+                                contacted within the specified timeout
+                                interval. The system manager will
+                                ensure to contact it at least once in
+                                half the specified timeout
+                                interval. This feature requires a
+                                hardware watchdog device to be
+                                present, as it is commonly the case in
+                                embedded and server systems. Not all
+                                hardware watchdogs allow configuration
+                                of the reboot timeout, in which case
+                                the closest available timeout is
+                                picked. <varname>ShutdownWatchdogSec=</varname>
+                                may be used to configure the hardware
+                                watchdog when the system is asked to
+                                reboot. It works as a safety net to
+                                ensure that the reboot takes place
+                                even if a clean reboot attempt times
+                                out. By default
+                                <varname>RuntimeWatchdogSec=</varname>
+                                defaults to 0 (off), and
+                                <varname>ShutdownWatchdogSec=</varname>
+                                to 10min. These settings have no
+                                effect if a hardware watchdog is not
+                                available.</para></listitem>
+                        </varlistentry>
+
+                        <varlistentry>
+                                <term><varname>DefaultLimitCPU=</varname></term>
+                                <term><varname>DefaultLimitFSIZE=</varname></term>
+                                <term><varname>DefaultLimitDATA=</varname></term>
+                                <term><varname>DefaultLimitSTACK=</varname></term>
+                                <term><varname>DefaultLimitCORE=</varname></term>
+                                <term><varname>DefaultLimitRSS=</varname></term>
+                                <term><varname>DefaultLimitNOFILE=</varname></term>
+                                <term><varname>DefaultLimitAS=</varname></term>
+                                <term><varname>DefaultLimitNPROC=</varname></term>
+                                <term><varname>DefaultLimitMEMLOCK=</varname></term>
+                                <term><varname>DefaultLimitLOCKS=</varname></term>
+                                <term><varname>DefaultLimitSIGPENDING=</varname></term>
+                                <term><varname>DefaultLimitMSGQUEUE=</varname></term>
+                                <term><varname>DefaultLimitNICE=</varname></term>
+                                <term><varname>DefaultLimitRTPRIO=</varname></term>
+                                <term><varname>DefaultLimitRTTIME=</varname></term>
+                                <listitem><para>These settings control
+                                various default resource limits for units. See
+                                <citerefentry><refentrytitle>setrlimit</refentrytitle><manvolnum>2</manvolnum></citerefentry>
+                                for details. Use the string
+                                <varname>infinity</varname> to
+                                configure no limit on a specific
+				resource. They can be overriden in units files
+				using corresponding LimitXXXX parameter.</para></listitem>
+                        </varlistentry>
                 </variablelist>
         </refsect1>
 
diff --git a/src/main.c b/src/main.c
index ed317b4..3f5f3d7 100644
--- a/src/main.c
+++ b/src/main.c
@@ -79,6 +79,7 @@ static char **arg_default_controllers = NULL;
 static char ***arg_join_controllers = NULL;
 static ExecOutput arg_default_std_output = EXEC_OUTPUT_JOURNAL;
 static ExecOutput arg_default_std_error = EXEC_OUTPUT_INHERIT;
+static struct rlimit *arg_default_rlimit[RLIMIT_NLIMITS] = {};
 
 static FILE* serialization = NULL;
 
@@ -659,6 +660,22 @@ static int parse_config_file(void) {
                 { "Manager", "DefaultStandardOutput", config_parse_output,       0, &arg_default_std_output  },
                 { "Manager", "DefaultStandardError",  config_parse_output,       0, &arg_default_std_error   },
                 { "Manager", "JoinControllers",       config_parse_join_controllers, 0, &arg_join_controllers },
+                { "Manager", "DefaultLimitCPU",       config_parse_limit,        0, &arg_default_rlimit[RLIMIT_CPU]},
+                { "Manager", "DefaultLimitFSIZE",     config_parse_limit,        0, &arg_default_rlimit[RLIMIT_FSIZE]},
+                { "Manager", "DefaultLimitDATA",      config_parse_limit,        0, &arg_default_rlimit[RLIMIT_DATA]},
+                { "Manager", "DefaultLimitSTACK",     config_parse_limit,        0, &arg_default_rlimit[RLIMIT_STACK]},
+                { "Manager", "DefaultLimitCORE",      config_parse_limit,        0, &arg_default_rlimit[RLIMIT_CORE]},
+                { "Manager", "DefaultLimitRSS",       config_parse_limit,        0, &arg_default_rlimit[RLIMIT_RSS]},
+                { "Manager", "DefaultLimitNOFILE",    config_parse_limit,        0, &arg_default_rlimit[RLIMIT_NOFILE]},
+                { "Manager", "DefaultLimitAS",        config_parse_limit,        0, &arg_default_rlimit[RLIMIT_AS]},
+                { "Manager", "DefaultLimitNPROC",     config_parse_limit,        0, &arg_default_rlimit[RLIMIT_NPROC]},
+                { "Manager", "DefaultLimitMEMLOCK",   config_parse_limit,        0, &arg_default_rlimit[RLIMIT_MEMLOCK]},
+                { "Manager", "DefaultLimitLOCKS",     config_parse_limit,        0, &arg_default_rlimit[RLIMIT_LOCKS]},
+                { "Manager", "DefaultLimitSIGPENDING",config_parse_limit,        0, &arg_default_rlimit[RLIMIT_SIGPENDING]},
+                { "Manager", "DefaultLimitMSGQUEUE",  config_parse_limit,        0, &arg_default_rlimit[RLIMIT_MSGQUEUE]},
+                { "Manager", "DefaultLimitNICE",      config_parse_limit,        0, &arg_default_rlimit[RLIMIT_NICE]},
+                { "Manager", "DefaultLimitRTPRIO",    config_parse_limit,        0, &arg_default_rlimit[RLIMIT_RTPRIO]},
+                { "Manager", "DefaultLimitRTTIME",    config_parse_limit,        0, &arg_default_rlimit[RLIMIT_RTTIME]},
                 { NULL, NULL, NULL, 0, NULL }
         };
 
@@ -1401,6 +1418,8 @@ int main(int argc, char *argv[]) {
         m->default_std_output = arg_default_std_output;
         m->default_std_error = arg_default_std_error;
 
+        manager_set_default_rlimits(m, arg_default_rlimit);
+
         if (dual_timestamp_is_set(&initrd_timestamp))
                 m->initrd_timestamp = initrd_timestamp;
 
@@ -1539,6 +1558,9 @@ finish:
         if (m)
                 manager_free(m);
 
+        for (j = 0; j < RLIMIT_NLIMITS; j++)
+                free (arg_default_rlimit[j]);
+
         free(arg_default_unit);
         strv_free(arg_default_controllers);
         free_join_controllers();
diff --git a/src/manager.c b/src/manager.c
index 74bd740..22eef3c 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -456,6 +456,7 @@ static void manager_clear_jobs_and_units(Manager *m) {
 
 void manager_free(Manager *m) {
         UnitType c;
+        int i;
 
         assert(m);
 
@@ -501,6 +502,9 @@ void manager_free(Manager *m) {
         hashmap_free(m->cgroup_bondings);
         set_free_free(m->unit_path_cache);
 
+        for (i = 0; i < RLIMIT_NLIMITS; i++)
+                free(m->rlimit[i]);
+
         free(m);
 }
 
@@ -3137,6 +3141,24 @@ int manager_set_default_controllers(Manager *m, char **controllers) {
         return 0;
 }
 
+int manager_set_default_rlimits(Manager *m, struct rlimit **default_rlimit) {
+        int i;
+
+        assert(m);
+
+        for (i = 0; i < RLIMIT_NLIMITS; i++) {
+                if (default_rlimit[i]) {
+                        m->rlimit[i] = newdup(struct rlimit, default_rlimit[i], 1);
+
+                        if (!m->rlimit[i])
+                                return -ENOMEM;
+                }
+        }
+
+        return 0;
+}
+
+
 void manager_recheck_journal(Manager *m) {
         Unit *u;
 
diff --git a/src/manager.h b/src/manager.h
index a9d08f0..5f5de8e 100644
--- a/src/manager.h
+++ b/src/manager.h
@@ -225,6 +225,8 @@ struct Manager {
 
         ExecOutput default_std_output, default_std_error;
 
+        struct rlimit *rlimit[RLIMIT_NLIMITS];
+
         /* non-zero if we are reloading or reexecuting, */
         int n_reloading;
 
@@ -263,6 +265,7 @@ unsigned manager_dispatch_run_queue(Manager *m);
 unsigned manager_dispatch_dbus_queue(Manager *m);
 
 int manager_set_default_controllers(Manager *m, char **controllers);
+int manager_set_default_rlimits(Manager *m, struct rlimit **default_rlimit);
 
 int manager_loop(Manager *m);
 
diff --git a/src/service.c b/src/service.c
index ec2725a..0da964e 100644
--- a/src/service.c
+++ b/src/service.c
@@ -108,6 +108,7 @@ static const UnitActiveState state_translation_table[_SERVICE_STATE_MAX] = {
 
 static void service_init(Unit *u) {
         Service *s = SERVICE(u);
+        int i;
 
         assert(u);
         assert(u->load_state == UNIT_STUB);
@@ -126,6 +127,9 @@ static void service_init(Unit *u) {
         s->guess_main_pid = true;
 
         exec_context_init(&s->exec_context);
+        for (i = 0; i < RLIMIT_NLIMITS; i++)
+                if (UNIT(s)->manager->rlimit[i])
+                        s->exec_context.rlimit[i] = newdup(struct rlimit, UNIT(s)->manager->rlimit[i], 1);
 
         RATELIMIT_INIT(s->start_limit, 10*USEC_PER_SEC, 5);
 
-- 
1.7.10.4

